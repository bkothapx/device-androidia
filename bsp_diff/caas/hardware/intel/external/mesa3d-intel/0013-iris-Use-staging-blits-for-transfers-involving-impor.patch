From 68f8500700f556de1dfef706b25a6637cdf75839 Mon Sep 17 00:00:00 2001
From: Kenneth Graunke <kenneth@whitecape.org>
Date: Thu, 20 May 2021 11:22:22 -0700
Subject: [PATCH 07/20] iris: Use staging blits for transfers involving
 imported BOs

Direct mappings of imported DMABUFs can be tricky.  If they're allocated
from our own device, then we can probably mmap them and it'd be fine.
But they may come from a different device (such as a discrete GPU), in
which case I915_GEM_MMAP wouldn't work, I915_GEM_MMAP_GTT would require
a working IOMMU, and directly mmap'ing the DMABUF fd would come with a
bunch of rules and restrictions which are hard to get right.

CPU mapping an imported DMABUF image for writes seems very uncommon,
solidly in the "what are you even doing?" realm.  Mapping an imported
DMABUF for reading might be a thing, in case someone wanted to do
glReadPixels on it.  But in that case, the cost of doing a staging
blit is probably acceptable.

Acked-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10941>

diff --git a/src/gallium/drivers/iris/iris_resource.c b/src/gallium/drivers/iris/iris_resource.c
index 0f91772a1e0..180ec7a6e29 100644
--- a/src/gallium/drivers/iris/iris_resource.c
+++ b/src/gallium/drivers/iris/iris_resource.c
@@ -1938,9 +1938,12 @@ iris_transfer_map(struct pipe_context *ctx,
    if (usage & (PIPE_MAP_PERSISTENT | PIPE_MAP_COHERENT))
       usage |= PIPE_MAP_DIRECTLY;
 
-   /* We cannot provide a direct mapping of tiled resources */
-   if (surf->tiling != ISL_TILING_LINEAR &&
-       (usage & PIPE_MAP_DIRECTLY))
+   /* We cannot provide a direct mapping of tiled resources, and we
+    * may not be able to mmap imported BOs since they may come from
+    * other devices that I915_GEM_MMAP cannot work with.
+    */
+   if ((usage & PIPE_MAP_DIRECTLY) &&
+       (surf->tiling != ISL_TILING_LINEAR || res->bo->imported))
       return NULL;
 
    bool map_would_stall = false;
@@ -1983,30 +1986,33 @@ iris_transfer_map(struct pipe_context *ctx,
    if (usage & PIPE_MAP_WRITE)
       util_range_add(&res->base.b, &res->valid_buffer_range, box->x, box->x + box->width);
 
-   /* GPU copies are not useful for buffer reads.  Instead of stalling to
-    * read from the original buffer, we'd simply copy it to a temporary...
-    * then stall (a bit longer) to read from that buffer.
-    *
-    * Images are less clear-cut.  Resolves can be destructive, removing some
-    * of the underlying compression, so we'd rather blit the data to a linear
-    * temporary and map that, to avoid the resolve.
-    */
-   if (!(usage & PIPE_MAP_DISCARD_RANGE) &&
-       !iris_has_invalid_primary(res, level, 1, box->z, box->depth)) {
-      usage |= PIPE_MAP_DIRECTLY;
-   }
+   if (!res->bo->imported) {
+      /* GPU copies are not useful for buffer reads.  Instead of stalling to
+       * read from the original buffer, we'd simply copy it to a temporary...
+       * then stall (a bit longer) to read from that buffer.
+       *
+       * Images are less clear-cut.  Resolves can be destructive, removing
+       * some of the underlying compression, so we'd rather blit the data to
+       * a linear temporary and map that, to avoid the resolve.
+       */
+      if (!(usage & PIPE_MAP_DISCARD_RANGE) &&
+          !iris_has_invalid_primary(res, level, 1, box->z, box->depth)) {
+         usage |= PIPE_MAP_DIRECTLY;
+      }
 
-   const struct isl_format_layout *fmtl = isl_format_get_layout(surf->format);
-   if (fmtl->txc == ISL_TXC_ASTC)
-      usage |= PIPE_MAP_DIRECTLY;
+      const struct isl_format_layout *fmtl =
+         isl_format_get_layout(surf->format);
+      if (fmtl->txc == ISL_TXC_ASTC)
+         usage |= PIPE_MAP_DIRECTLY;
 
-   /* We can map directly if it wouldn't stall, there's no compression,
-    * and we aren't doing an uncached read.
-    */
-   if (!map_would_stall &&
-       !isl_aux_usage_has_compression(res->aux.usage) &&
-       !((usage & PIPE_MAP_READ) && !res->bo->cache_coherent)) {
-      usage |= PIPE_MAP_DIRECTLY;
+      /* We can map directly if it wouldn't stall, there's no compression,
+       * and we aren't doing an uncached read.
+       */
+      if (!map_would_stall &&
+          !isl_aux_usage_has_compression(res->aux.usage) &&
+          !((usage & PIPE_MAP_READ) && !res->bo->cache_coherent)) {
+         usage |= PIPE_MAP_DIRECTLY;
+      }
    }
 
    if (!(usage & PIPE_MAP_DIRECTLY)) {
-- 
2.36.1

