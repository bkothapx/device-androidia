From 418f206265e502083b3498276499287e9ab6cb77 Mon Sep 17 00:00:00 2001
From: Kenneth Graunke <kenneth@whitecape.org>
Date: Thu, 20 May 2021 11:15:30 -0700
Subject: [PATCH 02/20] iris: Promote to MAP_DIRECTLY when required before NULL
 return

In some cases, we have to map directly (e.g. coherent/persistent maps).
In other cases (e.g. tiled), we /cannot/ map directly.  We should put
the code which adds the PIPE_MAP_DIRECTLY flag in mandatory cases before
the "bail and return NULL" check for cases where we can't do that.

We leave the "we would prefer to direct map this" cases after the error
check, since we -can- use blits for those, we'd just rather not.  ASTC
also stays because even though it's tiled, our tiled memcpy paths work.

Acked-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/10941>

diff --git a/src/gallium/drivers/iris/iris_resource.c b/src/gallium/drivers/iris/iris_resource.c
index 6c29d46ecae..c6050d84590 100644
--- a/src/gallium/drivers/iris/iris_resource.c
+++ b/src/gallium/drivers/iris/iris_resource.c
@@ -1929,6 +1929,20 @@ iris_transfer_map(struct pipe_context *ctx,
       usage |= PIPE_MAP_UNSYNCHRONIZED;
    }
 
+   /* Avoid using GPU copies for persistent/coherent buffers, as the idea
+    * there is to access them simultaneously on the CPU & GPU.  This also
+    * avoids trying to use GPU copies for our u_upload_mgr buffers which
+    * contain state we're constructing for a GPU draw call, which would
+    * kill us with infinite stack recursion.
+    */
+   if (usage & (PIPE_MAP_PERSISTENT | PIPE_MAP_COHERENT))
+      usage |= PIPE_MAP_DIRECTLY;
+
+   /* We cannot provide a direct mapping of tiled resources */
+   if (surf->tiling != ISL_TILING_LINEAR &&
+       (usage & PIPE_MAP_DIRECTLY))
+      return NULL;
+
    bool map_would_stall = false;
 
    if (!(usage & PIPE_MAP_UNSYNCHRONIZED)) {
@@ -1941,10 +1955,6 @@ iris_transfer_map(struct pipe_context *ctx,
          return NULL;
    }
 
-   if (surf->tiling != ISL_TILING_LINEAR &&
-       (usage & PIPE_MAP_DIRECTLY))
-      return NULL;
-
    struct iris_transfer *map;
 
    if (usage & TC_TRANSFER_MAP_THREADED_UNSYNC)
@@ -1973,15 +1983,6 @@ iris_transfer_map(struct pipe_context *ctx,
    if (usage & PIPE_MAP_WRITE)
       util_range_add(&res->base.b, &res->valid_buffer_range, box->x, box->x + box->width);
 
-   /* Avoid using GPU copies for persistent/coherent buffers, as the idea
-    * there is to access them simultaneously on the CPU & GPU.  This also
-    * avoids trying to use GPU copies for our u_upload_mgr buffers which
-    * contain state we're constructing for a GPU draw call, which would
-    * kill us with infinite stack recursion.
-    */
-   if (usage & (PIPE_MAP_PERSISTENT | PIPE_MAP_COHERENT))
-      usage |= PIPE_MAP_DIRECTLY;
-
    /* GPU copies are not useful for buffer reads.  Instead of stalling to
     * read from the original buffer, we'd simply copy it to a temporary...
     * then stall (a bit longer) to read from that buffer.
-- 
2.36.1

