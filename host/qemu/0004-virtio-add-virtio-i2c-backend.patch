From 9d11d3175b72fc4e7ee0888644416e8352361f86 Mon Sep 17 00:00:00 2001
From: Zhuocheng Ding <zhuocheng.ding@intel.com>
Date: Fri, 7 Aug 2020 09:18:05 +0800
Subject: [PATCH] virtio: add virtio-i2c backend

Tracked-On: OAM-92875
Signed-off-by: Zhuocheng Ding <zhuocheng.ding@intel.com>

diff --git a/hw/i2c/Kconfig b/hw/i2c/Kconfig
index 2bbd395813..d8b974cb27 100644
--- a/hw/i2c/Kconfig
+++ b/hw/i2c/Kconfig
@@ -24,3 +24,9 @@ config IMX_I2C
 config MPC_I2C
     bool
     select I2C
+
+config VIRTIO_I2C
+    bool
+    default y
+    select I2C
+    depends on VIRTIO
diff --git a/hw/i2c/Makefile.objs b/hw/i2c/Makefile.objs
index d7073a401f..6efaf968ad 100644
--- a/hw/i2c/Makefile.objs
+++ b/hw/i2c/Makefile.objs
@@ -9,5 +9,6 @@ common-obj-$(CONFIG_IMX_I2C) += imx_i2c.o
 common-obj-$(CONFIG_ASPEED_SOC) += aspeed_i2c.o
 common-obj-$(CONFIG_NRF51_SOC) += microbit_i2c.o
 common-obj-$(CONFIG_MPC_I2C) += mpc_i2c.o
+common-obj-$(CONFIG_VIRTIO_I2C) += virtio_i2c.o
 obj-$(CONFIG_OMAP) += omap_i2c.o
 obj-$(CONFIG_PPC4XX) += ppc4xx_i2c.o
diff --git a/hw/i2c/virtio_i2c.c b/hw/i2c/virtio_i2c.c
new file mode 100644
index 0000000000..e97b10943e
--- /dev/null
+++ b/hw/i2c/virtio_i2c.c
@@ -0,0 +1,313 @@
+/*
+ * Virtio I2C Device
+ *
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * Authors:
+ *  Zhuocheng Ding  <zhuocheng.ding@intel.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/module.h"
+#include "qapi/error.h"
+#include "hw/virtio/virtio.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-i2c.h"
+#include "standard-headers/linux/virtio_ids.h"
+#include <sys/ioctl.h>
+#include <linux/i2c-dev.h>
+#include "qom/object_interfaces.h"
+
+typedef QTAILQ_HEAD(, virtio_i2c_msg) VirtIOI2CMsgList;
+
+static void virtio_i2c_process_msgs(int fd, VirtIOI2CMsgList *msgs, int n, VirtQueue *vq) {
+    struct virtio_i2c_msg *msg;
+    struct i2c_rdwr_ioctl_data arg;
+    uint8_t *status;
+    int ret, i = 0;
+
+    arg.nmsgs = n;
+    arg.msgs = g_new0(struct i2c_msg, n);
+    QTAILQ_FOREACH(msg, msgs, next) {
+        arg.msgs[i++] = msg->msg;
+    }
+
+    i = 0;
+    ret = ioctl(fd, I2C_RDWR, &arg);
+    QTAILQ_FOREACH(msg, msgs, next) {
+        status = msg->elem.in_sg[msg->elem.in_num == 1 ? 0 : 1].iov_base;
+        *status = i++ < ret ? VIRTIO_I2C_MSG_OK : VIRTIO_I2C_MSG_ERR;
+        virtqueue_push(vq, &msg->elem, 1);
+    }
+
+    while (!QTAILQ_EMPTY(msgs)) {
+        msg = QTAILQ_FIRST(msgs);
+        QTAILQ_REMOVE(msgs, msg, next);
+        g_free(msg);
+    }
+    g_free(arg.msgs);
+}
+
+static void virtio_i2c_handle_output(VirtIODevice *vdev, VirtQueue *vq)
+{
+    VirtIOI2C *vi2c = VIRTIO_I2C(vdev);
+    struct virtio_i2c_msg *vmsg;
+    VirtIOI2CMsgList vmsgs;
+    struct virtio_i2c_hdr *hdr;
+    uint8_t *status;
+    VirtIOI2CAdapter *adapter, *prev_adapter = NULL;
+    int i = 0;
+
+    /* Messages are processed in batch to match native driver behavior. */
+    QTAILQ_INIT(&vmsgs);
+    for (;;) {
+        vmsg = virtqueue_pop(vi2c->vq, sizeof(struct virtio_i2c_msg));
+        if (!vmsg)
+            break;
+
+        /* undefined behavior */
+        if (vmsg->elem.out_num == 0 || vmsg->elem.out_num > 2 ||
+                vmsg->elem.in_num == 0 || vmsg->elem.in_num > 2 ||
+                (vmsg->elem.out_num == 2 && vmsg->elem.in_num == 2)) {
+            virtio_error(vdev, "virtio-i2c invalid request");
+            g_free(vmsg);
+            break;
+        }
+
+        hdr = vmsg->elem.out_sg[0].iov_base;
+        vmsg->msg.flags = hdr->flags;
+        vmsg->msg.len = hdr->len;
+        if (hdr->len) {
+            if (hdr->flags & I2C_M_RD)
+                vmsg->msg.buf = vmsg->elem.in_sg[0].iov_base;
+            else
+                vmsg->msg.buf = vmsg->elem.out_sg[1].iov_base;
+        } else {
+            vmsg->msg.buf = NULL;
+        }
+
+        status = vmsg->elem.in_sg[vmsg->elem.in_num == 1 ? 0 : 1].iov_base;
+        if (i < 0) {
+            *status = VIRTIO_I2C_MSG_ERR;
+            goto err;
+        }
+        if (hdr->addr < I2C_VDEV_OFFSET || hdr->addr >= vi2c->map->vdev_num + I2C_VDEV_OFFSET) {
+            *status = VIRTIO_I2C_MSG_NODEV;
+            goto err;
+        }
+        adapter = vi2c->adapters[vi2c->map->vdev[hdr->addr - I2C_VDEV_OFFSET].adap_idx];
+        if (adapter == NULL) {
+            *status = VIRTIO_I2C_MSG_NODEV;
+            goto err;
+        }
+        vmsg->msg.addr = vi2c->map->vdev[hdr->addr - I2C_VDEV_OFFSET].addr;
+
+        if (adapter != prev_adapter && prev_adapter != NULL) {
+            virtio_i2c_process_msgs(prev_adapter->fd, &vmsgs, i, vi2c->vq);
+            i = 0;
+        }
+        prev_adapter = adapter;
+        QTAILQ_INSERT_TAIL(&vmsgs, vmsg, next);
+        i++;
+        continue;
+
+err:
+        if (prev_adapter != NULL) {
+            virtio_i2c_process_msgs(prev_adapter->fd, &vmsgs, i, vi2c->vq);
+            prev_adapter = NULL;
+        }
+        virtqueue_push(vi2c->vq, &vmsg->elem, 1);
+        g_free(vmsg);
+        i = -1;
+    }
+
+    if (i > 0)
+        virtio_i2c_process_msgs(prev_adapter->fd, &vmsgs, i, vi2c->vq);
+    virtio_notify(vdev, vi2c->vq);
+}
+
+static uint64_t virtio_i2c_get_features(VirtIODevice *vdev, uint64_t f,
+                                        Error **errp)
+{
+    return f;
+}
+
+/*
+ * i2c-device=<bus>:<slave_addr>[:<slave_addr>]-[<bus>:<slave_addr>[:<slave_addr>]]
+ */
+static void virtio_i2c_parse(VirtIOI2C *vi2c, Error **errp)
+{
+    char *opt = vi2c->config;
+    VirtIOI2CAdapter *adapter;
+    char *p, path[20];
+    int addr, bus, i, n_adapter, n_slave;
+
+    if (!opt) {
+        error_setg(errp, "Option 'i2c-device' is required");
+        return;
+    }
+
+    vi2c->map = g_malloc0(sizeof(*vi2c->map));
+    n_adapter = 0;
+    while (*opt) {
+        bus = strtoul(opt, &p, 10);
+        if (p == opt || bus < 0) {
+            error_setg(errp, "'i2c-device' format is wrong");
+            goto err;
+        }
+        if (n_adapter >= MAX_HOST_I2C_ADAPTER) {
+            error_setg(errp, "too many host adapters, only support %d",
+                    MAX_HOST_I2C_ADAPTER);
+            goto err;
+        }
+        for (i = 0; i < MAX_HOST_I2C_ADAPTER; i++) {
+            if (vi2c->adapters[i] && vi2c->adapters[i]->bus == bus) {
+                error_setg(errp, "illegal: bus %d is specified twice", bus);
+                goto err;
+            }
+        }
+
+        adapter = vi2c->adapters[n_adapter++] =
+            g_malloc0(sizeof(VirtIOI2CAdapter));
+        adapter->bus = bus;
+        snprintf(path, sizeof(path), "/dev/i2c-%d", bus);
+        path[sizeof(path) - 1] = '\0';
+        adapter->fd = open(path, O_RDWR);
+        if (adapter->fd < 0) {
+            error_setg_errno(errp, errno, "failed to open /dev/i2c-%d", bus);
+            g_free(vi2c->adapters[--n_adapter]);
+            goto err;
+        }
+
+        n_slave = 0;
+        while (*p == ':') {
+            opt = p + 1;
+            addr = strtoul(opt, &p, 16);
+            if (p == opt || addr < 0 || addr > 127) {
+                error_setg(errp, "'i2c-device' format is wrong");
+                goto err;
+            }
+            if (test_bit(addr, adapter->vdev_enabled)) {
+                error_setg(errp, "bus %d: addr %x is specified twice", bus, addr);
+                goto err;
+            }
+            if (ioctl(adapter->fd, I2C_SLAVE, addr) < 0) {
+                if (errno == EBUSY) {
+                    error_setg(errp, "bus %d: slave device %x is busy", bus, addr);
+                } else {
+                    error_setg(errp, "bus %d: slave device %x does not exist", bus, addr);
+                }
+                goto err;
+            }
+
+            n_slave++;
+            set_bit(addr, adapter->vdev_enabled);
+            vi2c->map->vdev[vi2c->map->vdev_num].adap_idx = n_adapter - 1;
+            vi2c->map->vdev[vi2c->map->vdev_num++].addr = addr;
+        }
+
+        if (n_slave == 0) {
+            error_setg(errp, "'i2c-device' format is wrong");
+            goto err;
+        }
+
+        if (*p == '-') {
+            opt = p + 1;
+            if (*opt == '\0') {
+                error_setg(errp, "'i2c-device' format is wrong");
+                goto err;
+            }
+        } else if (*p == '\0') {
+            opt = p;
+        } else {
+            error_setg(errp, "'i2c-device' format is wrong");
+            goto err;
+        }
+    }
+    return;
+
+err:
+    for (i = 0; i < n_adapter; i++) {
+        close(vi2c->adapters[i]->fd);
+        g_free(vi2c->adapters[i]);
+    }
+    g_free(vi2c->map);
+    return;
+}
+
+static void virtio_i2c_device_realize(DeviceState *dev, Error **errp)
+{
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VirtIOI2C *vi2c = VIRTIO_I2C(dev);
+    Error *err = NULL;
+
+    virtio_i2c_parse(vi2c, &err);
+    if (err != NULL) {
+        error_propagate(errp, err);
+        return;
+    }
+
+    virtio_init(vdev, "virtio-i2c", VIRTIO_ID_I2C, 0);
+
+    vi2c->vq = virtio_add_queue(vdev, 64, virtio_i2c_handle_output);
+}
+
+static void virtio_i2c_device_unrealize(DeviceState *dev, Error **errp)
+{
+    int i;
+    VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    VirtIOI2C *vi2c = VIRTIO_I2C(dev);
+
+    virtio_del_queue(vdev, 0);
+    virtio_cleanup(vdev);
+    for (i = 0; i < MAX_HOST_I2C_ADAPTER && vi2c->adapters[i]; i++) {
+        close(vi2c->adapters[i]->fd);
+        g_free(vi2c->adapters[i]);
+    }
+    g_free(vi2c->map);
+}
+
+static const VMStateDescription vmstate_virtio_i2c = {
+    .name = "virtio-i2c",
+    .minimum_version_id = 1,
+    .version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_VIRTIO_DEVICE,
+        VMSTATE_END_OF_LIST()
+    },
+};
+
+static Property virtio_i2c_properties[] = {
+    DEFINE_PROP_STRING("i2c-device", VirtIOI2C, config),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_i2c_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
+
+    dc->props = virtio_i2c_properties;
+    dc->vmsd = &vmstate_virtio_i2c;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    vdc->realize = virtio_i2c_device_realize;
+    vdc->unrealize = virtio_i2c_device_unrealize;
+    vdc->get_features = virtio_i2c_get_features;
+}
+
+static const TypeInfo virtio_i2c_info = {
+    .name = TYPE_VIRTIO_I2C,
+    .parent = TYPE_VIRTIO_DEVICE,
+    .instance_size = sizeof(VirtIOI2C),
+    .class_init = virtio_i2c_class_init,
+};
+
+static void virtio_register_types(void)
+{
+    type_register_static(&virtio_i2c_info);
+}
+
+type_init(virtio_register_types)
diff --git a/hw/virtio/Makefile.objs b/hw/virtio/Makefile.objs
index e2f70fbb89..88924748bb 100644
--- a/hw/virtio/Makefile.objs
+++ b/hw/virtio/Makefile.objs
@@ -33,6 +33,7 @@ obj-$(CONFIG_VIRTIO_SCSI) += virtio-scsi-pci.o
 obj-$(CONFIG_VIRTIO_BLK) += virtio-blk-pci.o
 obj-$(CONFIG_VIRTIO_NET) += virtio-net-pci.o
 obj-$(CONFIG_VIRTIO_SERIAL) += virtio-serial-pci.o
+obj-$(CONFIG_VIRTIO_I2C) += virtio-i2c-pci.o
 endif
 else
 common-obj-y += vhost-stub.o
diff --git a/hw/virtio/virtio-i2c-pci.c b/hw/virtio/virtio-i2c-pci.c
new file mode 100644
index 0000000000..7d5540ad55
--- /dev/null
+++ b/hw/virtio/virtio-i2c-pci.c
@@ -0,0 +1,85 @@
+/*
+ * Virtio I2C PCI Bindings
+ *
+ * Copyright (c) 2020 Intel Corporation
+ *
+ * Authors:
+ *  Zhuocheng Ding  <zhuocheng.ding@intel.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ */
+
+#include "qemu/osdep.h"
+
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-i2c.h"
+#include "virtio-pci.h"
+#include "qemu/module.h"
+
+typedef struct VirtIOI2CPCI VirtIOI2CPCI;
+
+/*
+ * virtio-i2c-pci: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_I2C_PCI "virtio-i2c-pci-base"
+#define VIRTIO_I2C_PCI(obj) \
+        OBJECT_CHECK(VirtIOI2CPCI, (obj), TYPE_VIRTIO_I2C_PCI)
+
+struct VirtIOI2CPCI {
+    VirtIOPCIProxy parent_obj;
+    VirtIOI2C vdev;
+};
+
+static Property virtio_i2c_pci_properties[] = {
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_i2c_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VirtIOI2CPCI *dev = VIRTIO_I2C_PCI(vpci_dev);
+    DeviceState *vdev = DEVICE(&dev->vdev);
+
+    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
+    object_property_set_bool(OBJECT(vdev), true, "realized", errp);
+}
+
+static void virtio_i2c_pci_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+
+    k->realize = virtio_i2c_pci_realize;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    dc->props = virtio_i2c_pci_properties;
+    pcidev_k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;
+    pcidev_k->device_id = PCI_DEVICE_ID_VIRTIO_I2C;
+    pcidev_k->revision = VIRTIO_PCI_ABI_VERSION;
+    pcidev_k->class_id = PCI_CLASS_OTHERS;
+}
+
+static void virtio_i2c_pci_instance_init(Object *obj)
+{
+    VirtIOI2CPCI *dev = VIRTIO_I2C_PCI(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_I2C);
+}
+
+static const VirtioPCIDeviceTypeInfo virtio_i2c_pci_info = {
+    .base_name              = TYPE_VIRTIO_I2C_PCI,
+    .generic_name           = "virtio-i2c-pci",
+    .transitional_name      = "virtio-i2c-pci-transitional",
+    .non_transitional_name  = "virtio-i2c-pci-non-transitional",
+    .instance_size = sizeof(VirtIOI2CPCI),
+    .instance_init = virtio_i2c_pci_instance_init,
+    .class_init    = virtio_i2c_pci_class_init,
+};
+
+static void virtio_i2c_pci_register(void)
+{
+    virtio_pci_types_register(&virtio_i2c_pci_info);
+}
+
+type_init(virtio_i2c_pci_register)
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 1b7ea30946..6903adee21 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -86,6 +86,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_VIRTIO_9P          0x1009
 #define PCI_DEVICE_ID_VIRTIO_VSOCK       0x1012
 #define PCI_DEVICE_ID_VIRTIO_PMEM        0x1013
+#define PCI_DEVICE_ID_VIRTIO_I2C         0x103e
 #define PCI_DEVICE_ID_VIRTIO_GPIO        0x103F

 #define PCI_VENDOR_ID_REDHAT             0x1b36
diff --git a/include/hw/virtio/virtio-i2c.h b/include/hw/virtio/virtio-i2c.h
new file mode 100644
index 0000000000..9c9a655b77
--- /dev/null
+++ b/include/hw/virtio/virtio-i2c.h
@@ -0,0 +1,68 @@
+/*
+ * Virtio I2C Device
+ *
+ * Copyright (c) Intel Corporation
+ *
+ * Authors:
+ *  Zhuocheng Ding  <zhuocheng.ding@intel.com>
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ *
+ */
+
+#ifndef QEMU_VIRTIO_I2C_H
+#define QEMU_VIRTIO_I2C_H
+
+#include "hw/virtio/virtio.h"
+#include <linux/i2c.h>
+
+#define TYPE_VIRTIO_I2C "virtio-i2c-device"
+#define VIRTIO_I2C(obj) \
+        OBJECT_CHECK(VirtIOI2C, (obj), TYPE_VIRTIO_I2C)
+
+#define MAX_HOST_I2C_ADAPTER    16
+
+/* Address 0x0-0x7 and 0x78-0x7F are reserved */
+#define MAX_I2C_VDEV            128 - 16
+#define I2C_VDEV_OFFSET         8
+
+#define VIRTIO_I2C_MSG_OK       0
+#define VIRTIO_I2C_MSG_ERR      1
+#define VIRTIO_I2C_MSG_NODEV    2
+
+struct virtio_i2c_hdr {
+    uint16_t addr;      /* slave address */
+    uint16_t flags;
+    uint16_t len;       /* msg length */
+}__attribute__((packed));
+
+struct virtio_i2c_msg {
+    VirtQueueElement elem;
+    struct i2c_msg msg;
+    QTAILQ_ENTRY(virtio_i2c_msg) next;
+};
+
+typedef struct VirtIOI2CAdapter {
+    int fd;
+    int bus;
+    DECLARE_BITMAP(vdev_enabled, MAX_I2C_VDEV);
+} VirtIOI2CAdapter;
+
+typedef struct VirtIOI2CMap {
+    int vdev_num;
+    struct {
+        uint8_t adap_idx;
+        uint8_t addr;
+    } vdev[MAX_I2C_VDEV];
+} VirtIOI2CMap;
+
+typedef struct VirtIOI2C {
+    VirtIODevice parent_obj;
+    VirtQueue *vq;
+    char *config;
+    VirtIOI2CAdapter *adapters[MAX_HOST_I2C_ADAPTER];
+    VirtIOI2CMap *map;
+} VirtIOI2C;
+
+#endif
diff --git a/include/standard-headers/linux/virtio_ids.h b/include/standard-headers/linux/virtio_ids.h
index b00d28d565..e4610153b3 100644
--- a/include/standard-headers/linux/virtio_ids.h
+++ b/include/standard-headers/linux/virtio_ids.h
@@ -47,5 +47,6 @@
 #define VIRTIO_ID_FS           26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM         27 /* virtio pmem */
 #define VIRTIO_ID_GPIO         28 /* virtio GPIO */
+#define VIRTIO_ID_I2C          29 /* virtio i2c */

 #endif /* _LINUX_VIRTIO_IDS_H */
--
2.25.1

