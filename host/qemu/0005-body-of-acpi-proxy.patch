From b40ff64b199a251466c1e8e73e073d4a8696a395 Mon Sep 17 00:00:00 2001
From: Yan Zhao <yan.y.zhao@intel.com>
Date: Tue, 15 Sep 2020 09:05:06 +0800
Subject: [PATCH 1/3] body of acpi proxy

the acpi-proxy device can be created using qemu cmd
"-device acpi-proxy".

acpi-proxy device requires virtual bios to reserve ACPI range from
0x7fd7f000 - (0x7fd7f000 + 0x7000).

TODO: specify the reservation range through device parameters.

Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
---
 hw/i386/acpi-build.c                 | 158 +++++++++++++-
 hw/i386/pc_piix.c                    |   2 +
 hw/i386/pc_q35.c                     |   2 +
 hw/misc/Makefile.objs                |   1 +
 hw/misc/acpi_proxy.c                 | 315 +++++++++++++++++++++++++++
 include/hw/acpi/acpi_dev_interface.h |   1 +
 include/hw/misc/acpi_proxy.h         |  20 ++
 7 files changed, 498 insertions(+), 1 deletion(-)
 create mode 100644 hw/misc/acpi_proxy.c
 create mode 100644 include/hw/misc/acpi_proxy.h

diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 12ff55fcfb..875c268d63 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -49,7 +49,7 @@
 #include "hw/mem/memory-device.h"
 #include "sysemu/numa.h"
 #include "sysemu/reset.h"
-
+#include "hw/misc/acpi_proxy.h"
 /* Supported chipsets: */
 #include "hw/southbridge/piix.h"
 #include "hw/acpi/pcihp.h"
@@ -1049,6 +1049,155 @@ static void build_hpet_aml(Aml *table)
     aml_append(table, scope);
 }

+static void build_acpi_proxy_aml(Aml *table)
+{
+    Aml *scope = aml_scope("_SB");
+    Aml *field;
+
+    bool ambig;
+    Object *acpi_obj = object_resolve_path_type("",
+                                                 TYPE_ACPI_DEVICE_IF, &ambig);
+    Object *obj = object_resolve_path_type("", TYPE_ACPI_PROXY, &ambig);
+
+    if (!acpi_obj || !obj) {
+        return;
+    }
+
+    aml_append(scope,
+        aml_operation_region("PROC", AML_SYSTEM_MEMORY,
+            aml_int(ACPI_PROXY_BASE), ACPI_PROXY_LEN));
+
+    field = aml_field("PROC", AML_DWORD_ACC, AML_LOCK, AML_PRESERVE);
+    /* doorbell */
+    aml_append(field, aml_named_field("DOOR", 32));
+    /* notify type: value 1 for wmpv */
+    aml_append(field, aml_named_field("NPTH", 32));
+    /* notify value, e.g. 0x81 */
+    aml_append(field, aml_named_field("NVAL", 32));
+    /* offset of 0x1000 */
+    aml_append(field,
+            aml_reserved_field(ACPI_PROXY_COMMAND_REGION_SIZE * 8 -
+                               32  - 32 - 32));
+    /* 2-6th page for input arg info, 0x5000 */
+    aml_append(field,
+            aml_named_field("INPT", ACPI_PROXY_INPUT_REGION_SIZE * 8));
+    /* 7th page, output count: 0 or 1 */
+    aml_append(field, aml_named_field("OUPC", 32));
+    /* output type: integer, buffer, or string */
+    aml_append(field, aml_named_field("OUPT", 32));
+    /* output size */
+    aml_append(field, aml_named_field("OUPS", 32));
+    /* output data */
+    aml_append(field,
+            aml_named_field("OUPD", ACPI_PROXY_OUTPUT_REGION_SIZE * 8 -
+                            32 - 32 - 32));
+    aml_append(scope, field);
+    aml_append(scope, aml_mutex("PLCK", 0));
+    aml_append(table, scope);
+}
+
+__attribute__((unused))
+static void build_proxy_method(Aml *method, Aml *method_path, int input_cnt)
+{
+    Aml *if_ctx;
+    Aml *else_ctx;
+    Aml *one = aml_int(1);
+    Aml *input = aml_local(0);
+    Aml *out_cnt = aml_local(1);
+    Aml *out_type = aml_local(2);
+    Aml *out_size = aml_local(3);
+    Aml *out_buf = aml_local(4);
+    Aml *type_buffer = aml_int(ACPI_TYPE_BUFFER);
+    Aml *type_string = aml_int(ACPI_TYPE_STRING);
+    Aml *type_int = aml_int(ACPI_TYPE_INTEGER);
+    int i;
+
+    /* acquire proxy lock */
+    aml_append(method, aml_acquire(aml_name("\\_SB.PLCK"), 0xFFFF));
+    aml_append(method, aml_to_buffer(input, input));
+    /* input arg count: arg count + method name */
+    aml_append(method, aml_store(aml_int(input_cnt + 1), input));
+    /* method name type: string */
+    aml_append(method,
+            aml_concatenate(input, aml_object_type(method_path), input));
+    /* method name size */
+    aml_append(method, aml_concatenate(input, aml_sizeof(method_path), input));
+    /* arg 0, value=method name */
+    aml_append(method, aml_concatenate(input, method_path, input));
+
+    for (i = 0; i < input_cnt; i++) {
+        Aml *arg = aml_arg(i);
+
+        /* arg type */
+        aml_append(method, aml_concatenate(input, aml_object_type(arg), input));
+        /* arg size */
+        aml_append(method, aml_concatenate(input, aml_sizeof(arg), input));
+        /* arg value */
+        aml_append(method, aml_concatenate(input, arg, input));
+    }
+
+    aml_append(method, aml_store(input, aml_name("\\_SB.INPT")));
+    /* ring doorbell */
+    aml_append(method, aml_store(aml_int(1), aml_name("\\_SB.DOOR")));
+    /* output count: 0 or 1 */
+    aml_append(method, aml_store(aml_name("\\_SB.OUPC"), out_cnt));
+    /* ouput type: integer, buffer, or strinig */
+    aml_append(method, aml_store(aml_name("\\_SB.OUPT"), out_type));
+    /* output size */
+    aml_append(method, aml_store(aml_name("\\_SB.OUPS"), out_size));
+
+    out_cnt = aml_to_integer(out_cnt);
+    out_type = aml_to_integer(out_type);
+    out_size = aml_to_integer(out_size);
+    if_ctx = aml_if(aml_equal(out_cnt, one));
+    {
+        Aml *if_subctx, *else_subctx;
+
+        aml_append(if_ctx, aml_store(aml_name("\\_SB.OUPD"), out_buf));
+
+        /*finished output data read, can unlock now, release proxy lock */
+        aml_append(if_ctx, aml_release(aml_name("\\_SB.PLCK")));
+
+        if_subctx = aml_if(aml_equal(out_type, type_buffer));
+        {
+            aml_append(if_subctx,
+                    aml_create_field(out_buf, aml_int(0), out_size, "OBUF"));
+            aml_append(if_subctx, aml_return(aml_name("OBUF")));
+        }
+        aml_append(if_ctx, if_subctx);
+        else_subctx = aml_else();
+        {
+            Aml *el_if_subctx, *el_else_subctx;
+
+            el_if_subctx = aml_if(aml_equal(out_type, type_string));
+            {
+                aml_append(el_if_subctx, aml_to_hexstring(out_buf, out_buf));
+                aml_append(el_if_subctx, aml_return(out_buf));
+            }
+            aml_append(else_subctx, el_if_subctx);
+            el_else_subctx = aml_else();
+            {
+                Aml *el_el_if_subctx;
+                el_el_if_subctx = aml_if(aml_equal(out_type, type_int));
+                {
+                    aml_append(el_el_if_subctx,
+                            aml_return(aml_to_integer(out_buf)));
+                }
+                aml_append(el_else_subctx, el_el_if_subctx);
+            }
+            aml_append(else_subctx, el_else_subctx);
+        }
+        aml_append(if_ctx, else_subctx);
+    }
+    aml_append(method, if_ctx);
+    else_ctx = aml_else();
+    {
+        /* release proxy lock */
+        aml_append(else_ctx, aml_release(aml_name("\\_SB.PLCK")));
+    }
+    aml_append(method, else_ctx);
+}
+
 static Aml *build_fdinfo_aml(int idx, FloppyDriveType type)
 {
     Aml *dev, *fdi;
@@ -1855,6 +2004,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         aml_append(dsdt, sb_scope);

         build_hpet_aml(dsdt);
+        build_acpi_proxy_aml(dsdt);
         build_piix4_pm(dsdt);
         build_piix4_isa_bridge(dsdt);
         build_isa_devices_aml(dsdt);
@@ -1872,6 +2022,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         aml_append(dsdt, sb_scope);

         build_hpet_aml(dsdt);
+        build_acpi_proxy_aml(dsdt);
         build_q35_isa_bridge(dsdt);
         build_isa_devices_aml(dsdt);
         build_q35_pci0_int(dsdt);
@@ -1909,6 +2060,11 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
             aml_append(scope, method);
         }

+        method = aml_method("_E07", 0, AML_NOTSERIALIZED);
+        aml_append(method, aml_store(aml_name("\\_SB.NPTH"), aml_local(1)));
+        aml_append(method, aml_store(aml_name("\\_SB.NVAL"), aml_local(2)));
+        aml_append(scope, method);
+
         if (machine->nvdimms_state->is_enabled) {
             method = aml_method("_E04", 0, AML_NOTSERIALIZED);
             aml_append(method, aml_notify(aml_name("\\_SB.NVDR"),
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 1bd70d1abb..0886329df9 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -33,6 +33,7 @@
 #include "hw/pci-host/i440fx.h"
 #include "hw/southbridge/piix.h"
 #include "hw/display/ramfb.h"
+#include "hw/misc/acpi_proxy.h"
 #include "hw/firmware/smbios.h"
 #include "hw/pci/pci.h"
 #include "hw/pci/pci_ids.h"
@@ -422,6 +423,7 @@ static void pc_i440fx_machine_options(MachineClass *m)
     m->default_machine_opts = "firmware=bios-256k.bin";
     m->default_display = "std";
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_ACPI_PROXY);
 }

 static void pc_i440fx_4_2_machine_options(MachineClass *m)
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 385e5cffb1..1ee5486e2e 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -49,6 +49,7 @@
 #include "hw/firmware/smbios.h"
 #include "hw/ide/pci.h"
 #include "hw/ide/ahci.h"
+#include "hw/misc/acpi_proxy.h"
 #include "hw/usb.h"
 #include "qapi/error.h"
 #include "qemu/error-report.h"
@@ -345,6 +346,7 @@ static void pc_q35_machine_options(MachineClass *m)
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_AMD_IOMMU_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_INTEL_IOMMU_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_ACPI_PROXY);
     m->max_cpus = 288;
 }

diff --git a/hw/misc/Makefile.objs b/hw/misc/Makefile.objs
index ba898a5781..bace1c0fd4 100644
--- a/hw/misc/Makefile.objs
+++ b/hw/misc/Makefile.objs
@@ -8,6 +8,7 @@ common-obj-$(CONFIG_ISA_TESTDEV) += pc-testdev.o
 common-obj-$(CONFIG_PCI_TESTDEV) += pci-testdev.o
 common-obj-$(CONFIG_EDU) += edu.o
 common-obj-$(CONFIG_PCA9552) += pca9552.o
+common-obj-y += acpi_proxy.o

 common-obj-$(CONFIG_UNIMP) += unimp.o
 common-obj-$(CONFIG_FW_CFG_DMA) += vmcoreinfo.o
diff --git a/hw/misc/acpi_proxy.c b/hw/misc/acpi_proxy.c
new file mode 100644
index 0000000000..ce6e3847b7
--- /dev/null
+++ b/hw/misc/acpi_proxy.c
@@ -0,0 +1,315 @@
+#include "qemu/osdep.h"
+#include "hw/sysbus.h"
+#include "hw/misc/acpi_proxy.h"
+#include "qemu/main-loop.h"
+#include "qapi/error.h"
+#include "qemu/error-report.h"
+#include "qapi/qapi-commands-misc.h"
+#include "hw/acpi/acpi_dev_interface.h"
+
+#ifdef ACPI_PROXY_DEBUG
+#define DPRINTF printf
+#else
+#define DPRINTF(...)
+#endif
+
+typedef struct ACPIProxyState {
+    /*< private >*/
+    SysBusDevice parent_obj;
+    /*< public >*/
+
+    MemoryRegion cmd_region;
+    MemoryRegion cmd_region_pt;
+    void *cmd_data;
+    void *cmd_trap;
+
+    char *proxy_buffer;
+    int call_fd;
+
+} ACPIProxyState;
+
+union ACPI_ARG_TYPE {
+    char *string;
+    char *buffer;
+    int  integer;
+};
+#define PROXY_CALL_PATH "/dev/acpi_mediator"
+
+#define REGION_TRAP_BASE 0x0
+#define REGION_TRAP_SIZE ACPI_PROXY_COMMAND_REGION_SIZE
+
+#define REGION_PT_BASE (REGION_TRAP_BASE + REGION_TRAP_SIZE)
+#define INPUT_SIZE ACPI_PROXY_INPUT_REGION_SIZE
+#define OUTPUT_SIZE ACPI_PROXY_OUTPUT_REGION_SIZE
+#define REGION_PT_SIZE (INPUT_SIZE + OUTPUT_SIZE)
+
+
+#define TO_PT_OFFSET(offset) (offset - REGION_PT_BASE)
+#define TO_TRAP_OFFSET(offset) (offset - REGION_TRAP_BASE)
+
+
+#define OFFSET_DOORBELL 0x0
+#define OFFSET_NOTIFY_TYPE 0x4
+#define OFFSET_NOTIFY_VALUE 0x8
+
+
+#define OFFSET_INPUT_BASE (REGION_PT_BASE + 0)
+#define OFFSET_INPUT_ARG_CNT OFFSET_INPUT_BASE
+
+#define OFFSET_OUTPUT_BASE (OFFSET_INPUT_BASE + INPUT_SIZE)
+#define OFFSET_OUTPUT_CNT (OFFSET_OUTPUT_BASE + 0x0)
+#define OFFSET_OUTPUT_TYPE (OFFSET_OUTPUT_BASE + 0x4)
+#define OFFSET_OUTPUT_SIZE (OFFSET_OUTPUT_BASE + 0x8)
+#define OFFSET_OUTPUT_DATA (OFFSET_OUTPUT_BASE + 0xc)
+
+/* 0x20 is a arbitary reserved size. can adjust in need */
+#define OUTPUT_DATA_SIZE_MAX (0x1000 - 0x20)
+#define BUFFER_SIZE INPUT_SIZE
+
+static void acpi_proxy_call_input(ACPIProxyState *s)
+{
+    unsigned int arg_cnt, i;
+    unsigned int input_offset = 0;
+    char *buffer = s->proxy_buffer;
+    unsigned long pos = 0;
+    unsigned int written = 0;
+
+    arg_cnt = *(int *)(s->cmd_data + input_offset);
+    input_offset += 4;
+
+    if (arg_cnt < 1) {
+        DPRINTF("invalid method called from guest, no method name found\n");
+        return;
+    }
+
+    memset(buffer, 0, BUFFER_SIZE);
+
+    *((uint32_t *)(buffer + pos)) = arg_cnt;
+    pos += sizeof(uint32_t);
+
+    for (i = 0; i < arg_cnt; i++) {
+        uint32_t arg_type, arg_size;
+
+        arg_type = *(uint32_t *)(s->cmd_data + input_offset);
+        *((uint32_t *)(buffer + pos)) = arg_type;
+        input_offset += sizeof(uint32_t);
+        pos += sizeof(uint32_t);
+
+        arg_size = *(uint32_t *)(s->cmd_data + input_offset);
+
+        /* for string type, sometime the arg_size is 1 byte less */
+        if (arg_type == ACPI_TYPE_STRING && arg_size > 0 &&
+                (*((char *)s->cmd_data + input_offset +
+                   arg_size - 1) != '\0')) {
+           arg_size++;
+        }
+
+        *((uint32_t *)(buffer + pos)) = arg_size;
+        input_offset += sizeof(uint32_t);
+        pos += sizeof(uint32_t);
+
+        memcpy(buffer + pos, s->cmd_data + input_offset, arg_size);
+        input_offset += arg_size;
+        pos += arg_size;
+    }
+
+    written = write(s->call_fd, s->proxy_buffer, pos);
+    if (written != pos) {
+        DPRINTF("error to call acpi_call\n");
+    }
+}
+
+static void acpi_proxy_call_output(ACPIProxyState *s)
+{
+    char *buffer = s->proxy_buffer;
+    int read_cnt = 0;
+    uint32_t output_cnt = 0;
+    uint32_t output_len = 0;
+    uint32_t output_type = 0;
+    unsigned long pos = 0;
+
+    memset(buffer, 0, BUFFER_SIZE);
+    read_cnt = read(s->call_fd, buffer, BUFFER_SIZE);
+    buffer = s->proxy_buffer;
+
+    memset(s->cmd_data + TO_PT_OFFSET(OFFSET_OUTPUT_BASE), 0,  OUTPUT_SIZE);
+
+    output_cnt =  *((uint32_t *)(buffer + pos));
+    pos += sizeof(uint32_t);
+
+    if (output_cnt > 1) {
+        DPRINTF("too many output count, output_cnt=%d\n", output_cnt);
+        return;
+    }
+
+    output_type = *((uint32_t *)(buffer + pos));
+    pos += sizeof(uint32_t);
+
+    output_len = *((uint32_t *)(buffer + pos));
+    pos += sizeof(uint32_t);
+
+    if (pos + output_len > read_cnt || pos + output_len > OUTPUT_SIZE) {
+        DPRINTF("too many output data, trucated! pos=%ld, output_len=%d, read_cnt=%d\n",
+                pos, output_len, read_cnt);
+        output_len = OUTPUT_SIZE - pos;
+    }
+
+    memcpy(s->cmd_data + TO_PT_OFFSET(OFFSET_OUTPUT_DATA),
+            buffer + pos, output_len);
+
+    *((int *)(s->cmd_data + TO_PT_OFFSET(OFFSET_OUTPUT_TYPE))) = output_type;
+    *((int *)(s->cmd_data + TO_PT_OFFSET(OFFSET_OUTPUT_CNT))) = output_cnt;
+    /* in guest acpi, the length is in bit */
+    *((int *)(s->cmd_data + TO_PT_OFFSET(OFFSET_OUTPUT_SIZE))) = output_len * 8;
+}
+
+static void acpi_proxy_call_native(ACPIProxyState *s)
+{
+    acpi_proxy_call_input(s);
+    acpi_proxy_call_output(s);
+}
+
+static uint64_t acpi_proxy_read(void *opaque, hwaddr addr,
+                              unsigned size)
+{
+    ACPIProxyState *s = opaque;
+    uint64_t ret;
+
+    if (addr >= REGION_TRAP_SIZE) {
+        return 0;
+    }
+
+    ret = *((int *)(s->cmd_trap + addr));
+    return ret;
+}
+
+static void acpi_proxy_write(void *opaque, hwaddr addr,
+                           uint64_t value, unsigned size)
+{
+    ACPIProxyState *s = opaque;
+
+    if (size != 4) {
+        DPRINTF("acpi_proxy_write, unsupported write length %x\n", size);
+        return;
+    }
+
+    switch (addr) {
+    case TO_TRAP_OFFSET(OFFSET_DOORBELL):
+        acpi_proxy_call_native(s);
+        break;
+    default:
+        DPRINTF("acpi_proxy_write, unsupported offset %" PRIx64 "\n", addr);
+        break;
+    }
+
+    return;
+}
+
+static const MemoryRegionOps acpi_proxy_ops = {
+    .read = acpi_proxy_read,
+    .write = acpi_proxy_write,
+    .valid = {
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+    .endianness = DEVICE_NATIVE_ENDIAN,
+};
+
+static void acpi_proxy_free_state(ACPIProxyState *s)
+{
+    if (s->call_fd >= 0) {
+        close(s->call_fd);
+        s->call_fd = -1;
+    }
+
+    if (s->cmd_data) {
+        free(s->cmd_data);
+        s->cmd_data = NULL;
+    }
+    if (s->cmd_trap) {
+        free(s->cmd_trap);
+        s->cmd_trap = NULL;
+    }
+}
+
+
+static void acpi_proxy_realize(DeviceState *dev, Error **errp)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
+    ACPIProxyState *s = ACPI_PROXY(dev);
+    uintptr_t page_size = qemu_real_host_page_size;
+
+    int fd = open(PROXY_CALL_PATH, O_RDWR);
+
+    if (fd < 0) {
+        error_setg_errno(errp, errno, "cannot open %s", PROXY_CALL_PATH);
+        error_append_hint(errp, "try modprobe acpi_mediator");
+        return;
+    }
+
+    s->call_fd = fd;
+
+    s->cmd_data = qemu_try_memalign(page_size, REGION_PT_SIZE);
+    if (!s->cmd_data) {
+        goto error;
+    }
+    memset(s->cmd_data, 0, REGION_PT_SIZE);
+
+    s->cmd_trap = qemu_try_memalign(page_size, REGION_TRAP_SIZE);
+    if (!s->cmd_trap) {
+        goto error;
+    }
+
+    memory_region_init_io(&s->cmd_region, OBJECT(dev), &acpi_proxy_ops, s,
+            "acpi-proxy", ACPI_PROXY_LEN);
+    sysbus_init_mmio(sbd, &s->cmd_region);
+    memory_region_init_ram_ptr(&s->cmd_region_pt, OBJECT(dev), "proxy cmd",
+            REGION_PT_SIZE, s->cmd_data);
+    memory_region_add_subregion_overlap(&s->cmd_region, REGION_PT_BASE,
+                                            &s->cmd_region_pt, 30);
+
+    s->proxy_buffer = g_malloc(BUFFER_SIZE);
+
+    sysbus_mmio_map(sbd, 0, ACPI_PROXY_BASE);
+    return;
+
+error:
+    acpi_proxy_free_state(s);
+}
+
+static void acpi_proxy_unrealize(DeviceState *dev, Error **errp)
+{
+    ACPIProxyState *s = ACPI_PROXY(dev);
+
+    acpi_proxy_free_state(s);
+}
+
+static void acpi_proxy_init(Object *obj)
+{
+
+}
+
+static void acpi_proxy_device_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->desc = "Proxy Device to pass through guest ACPI calls to native";
+    dc->realize = acpi_proxy_realize;
+    dc->unrealize = acpi_proxy_unrealize;
+    dc->user_creatable = true;
+}
+
+static const TypeInfo acpi_proxy_device_info = {
+    .name          = TYPE_ACPI_PROXY,
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(ACPIProxyState),
+    .instance_init = acpi_proxy_init,
+    .class_init    = acpi_proxy_device_class_init,
+};
+
+static void acpi_proxy_register_types(void)
+{
+    type_register_static(&acpi_proxy_device_info);
+}
+
+type_init(acpi_proxy_register_types)
diff --git a/include/hw/acpi/acpi_dev_interface.h b/include/hw/acpi/acpi_dev_interface.h
index a2a12af9b9..487fdd1801 100644
--- a/include/hw/acpi/acpi_dev_interface.h
+++ b/include/hw/acpi/acpi_dev_interface.h
@@ -14,6 +14,7 @@ typedef enum {
     ACPI_NVDIMM_HOTPLUG_STATUS = 16,
     ACPI_VMGENID_CHANGE_STATUS = 32,
     ACPI_POWER_DOWN_STATUS = 64,
+    ACPI_PROXY_STATUS = 128,
 } AcpiEventStatusBits;

 #define TYPE_ACPI_DEVICE_IF "acpi-device-interface"
diff --git a/include/hw/misc/acpi_proxy.h b/include/hw/misc/acpi_proxy.h
new file mode 100644
index 0000000000..aa48d4b196
--- /dev/null
+++ b/include/hw/misc/acpi_proxy.h
@@ -0,0 +1,20 @@
+#ifndef HW_ACPI_PROXY_H
+#define HW_ACPI_PROXY_H
+
+#include "qom/object.h"
+
+#define ACPI_PROXY_BASE         0x7fd7f000
+#define ACPI_PROXY_LEN          0x7000
+
+#define TYPE_ACPI_PROXY "acpi-proxy"
+#define ACPI_PROXY(obj) OBJECT_CHECK(ACPIProxyState, (obj), TYPE_ACPI_PROXY)
+
+#define ACPI_PROXY_COMMAND_REGION_SIZE 0x1000
+#define ACPI_PROXY_INPUT_REGION_SIZE 0x5000
+#define ACPI_PROXY_OUTPUT_REGION_SIZE 0x1000
+
+#define ACPI_TYPE_INTEGER               0x01
+#define ACPI_TYPE_STRING                0x02
+#define ACPI_TYPE_BUFFER                0x03
+
+#endif
--
2.17.1

