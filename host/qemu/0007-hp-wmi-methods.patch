From b5ac98ae646e931e90fe51d590c51ad3b65a2528 Mon Sep 17 00:00:00 2001
From: Yan Zhao <yan.y.zhao@intel.com>
Date: Wed, 16 Sep 2020 13:44:29 +0800
Subject: [PATCH 3/3] hp wmi methods

generating acpi table for hp wmi device.

currently 3 acpi methods called from guest are implemented:
WMPV, _WDG, _WED

Signed-off-by: Yan Zhao <yan.y.zhao@intel.com>
---
 hw/i386/acpi-build.c | 44 ++++++++++++++++++++++++++++++++++++++++++++
 hw/misc/acpi_proxy.c | 13 +++++++++++++
 2 files changed, 57 insertions(+)

diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 875c268d63..c627b4cb47 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -1198,6 +1198,42 @@ static void build_proxy_method(Aml *method, Aml *method_path, int input_cnt)
     aml_append(method, else_ctx);
 }

+static void build_wmi_aml(Aml *table)
+{
+    Aml *method;
+    Aml *scope = aml_scope("_SB");
+    Aml *dev = aml_device("WMIV");
+    int arg_cnt;
+
+    bool ambig;
+    Object *acpi_obj = object_resolve_path_type("",
+                                                 TYPE_ACPI_DEVICE_IF, &ambig);
+    Object *obj = object_resolve_path_type("", TYPE_ACPI_PROXY, &ambig);
+
+    if (!acpi_obj || !obj) {
+        return;
+    }
+
+    aml_append(dev, aml_name_decl("_HID", aml_eisaid("PNP0C14")));
+    aml_append(dev, aml_name_decl("_UID", aml_int(0x02)));
+    method = aml_method("_WDG", 0, AML_NOTSERIALIZED);
+    build_proxy_method(method, aml_string("\\_SB.WMIV._WDG"), 0);
+    aml_append(dev, method);
+
+    arg_cnt = 3;
+    method = aml_method("WMPV", arg_cnt, AML_SERIALIZED);
+    build_proxy_method(method, aml_string("\\_SB.WMIV.WMPV"), arg_cnt);
+    aml_append(dev, method);
+
+    arg_cnt = 1;
+    method = aml_method("_WED", arg_cnt, AML_SERIALIZED);
+    build_proxy_method(method, aml_string("\\_SB.WMIV._WED"), arg_cnt);
+    aml_append(dev, method);
+
+    aml_append(scope, dev);
+    aml_append(table, scope);
+}
+
 static Aml *build_fdinfo_aml(int idx, FloppyDriveType type)
 {
     Aml *dev, *fdi;
@@ -2005,6 +2041,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,

         build_hpet_aml(dsdt);
         build_acpi_proxy_aml(dsdt);
+        build_wmi_aml(dsdt);
         build_piix4_pm(dsdt);
         build_piix4_isa_bridge(dsdt);
         build_isa_devices_aml(dsdt);
@@ -2023,6 +2060,7 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,

         build_hpet_aml(dsdt);
         build_acpi_proxy_aml(dsdt);
+        build_wmi_aml(dsdt);
         build_q35_isa_bridge(dsdt);
         build_isa_devices_aml(dsdt);
         build_q35_pci0_int(dsdt);
@@ -2049,6 +2087,8 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,

     scope =  aml_scope("_GPE");
     {
+        Aml *if_ctx;
+
         aml_append(scope, aml_name_decl("_HID", aml_string("ACPI0006")));

         if (misc->is_piix4) {
@@ -2063,6 +2103,10 @@ build_dsdt(GArray *table_data, BIOSLinker *linker,
         method = aml_method("_E07", 0, AML_NOTSERIALIZED);
         aml_append(method, aml_store(aml_name("\\_SB.NPTH"), aml_local(1)));
         aml_append(method, aml_store(aml_name("\\_SB.NVAL"), aml_local(2)));
+        if_ctx = aml_if(aml_equal(aml_to_integer(aml_local(1)), aml_int(1)));
+        aml_append(if_ctx, aml_notify(aml_name("\\_SB.WMIV"),
+                    aml_to_integer(aml_local(2))));
+        aml_append(method, if_ctx);
         aml_append(scope, method);

         if (machine->nvdimms_state->is_enabled) {
diff --git a/hw/misc/acpi_proxy.c b/hw/misc/acpi_proxy.c
index 41dfc0d644..4533dbd4d5 100644
--- a/hw/misc/acpi_proxy.c
+++ b/hw/misc/acpi_proxy.c
@@ -65,6 +65,8 @@ union ACPI_ARG_TYPE {
 /* 0x20 is a arbitary reserved size. can adjust in need */
 #define OUTPUT_DATA_SIZE_MAX (0x1000 - 0x20)
 #define BUFFER_SIZE INPUT_SIZE
+#define HP_WMI "\\_SB.WMIV"
+

 static void acpi_proxy_call_input(ACPIProxyState *s)
 {
@@ -308,7 +310,18 @@ void qmp_acpi_gpe_notify(const char *id, int64_t val1,
     Object *obj = object_resolve_path_type("", TYPE_ACPI_PROXY, &ambig);
     if (obj && acpi_obj) {
         ACPIProxyState *s = ACPI_PROXY(obj);
+        AcpiDeviceIfClass *adevc = ACPI_DEVICE_IF_GET_CLASS(acpi_obj);
         memset(s->cmd_trap, 0, REGION_TRAP_SIZE);
+        if (!strcmp(id, HP_WMI)) {
+            *((int *)(s->cmd_trap +
+                        TO_TRAP_OFFSET(OFFSET_NOTIFY_TYPE))) = 1;
+            *((int *)(s->cmd_trap +
+                        TO_TRAP_OFFSET(OFFSET_NOTIFY_VALUE))) = val1;
+            if (adevc->send_event) {
+                AcpiDeviceIf *adev = ACPI_DEVICE_IF(acpi_obj);
+                adevc->send_event(adev, ACPI_PROXY_STATUS);
+            }
+        }
     } else {
         error_report("command is not supported, missing ACPI device");
     }
--
2.17.1

